---
  title: "Relativism vs Absolutism: Structuring your projects"
  date: 2021-01-24
  tags:
    - Discussing
    - Opinion
    - Abstract
  featured: true
  showcase: "./assets/showcase.png"
---
Strange, I know. What does this topic have to do with a software developer, and is it even applicable to programming? Bear with me here; I'm fully aware that the issue is typically associated with philosophy or some subset of ethics, but I believe it has some implications when you start structuring or planning your applications. It can give you some insights on your project, how it scales, and your actions' consequences.

Before I start rambling on about how I reflect about this in my day-to-day life as a software developer, let me first get some definitions out of the way.

<Seperator />

## Absolutism
Everything is fixed. Think of black and white statementsâ€”a set of rules that have no exceptions.  These are concepts that are quick to pick up and easy to understand.

I think this tends to be some peoples go-to because of its simplicity. It gives you structure and a guide to follow, but can we take a moment to explore the complications of this approach. Surely, you can't expect situations to arise without having exceptions. 

Yeah, you can easily say if you're hungry, you must eat. That's simple enough, but it gets more complicated. Never tell a lie; the possibility for exceptions start appearing. What if the benefits outweigh the drawbacks of telling a lie. Well, you need to start weighing the pros and cons. Once you start doing that the scope of absolutism gets broken into relativism. So keep it simple and don't lie; let the need for an absolutism structure, triumph the sense of a fair outcome.

<Seperator />

## Relativism
The complete opposite of absolutism. Everything is relative, no inherent wrong or right. Exposing situations for the grey areas they are. Finding resolute from the context from which it operates in.

This is significantly more complex than absolutism but allows for justification. Still, it's hard to think of it without involving some form of a starting point with an occupying outcome. If everything is neither right nor wrong, then how would you go about starting and ending. It would be an endless cycle of buts. Assuming you even have a point to start from. It's both never-ending and never-starting.

Aside from its complete impossibility, it requires too much computation to evaluate every possible subbranch of possibility. Handling every situation, with the idea that it could have multiple exceptions, would yield time spent on trivial matters while more complicated issues are set to the side.

<Seperator />

# The implications
Ok, its time to connect the dots; how does this relate to software development? I often see people asking how they should structure their projects; a simple question with a sometimes annoying answer: **It depends.**

They're not wrong, it truly does depend. Given the context of this post, it neither fits relativism nor absolutism. In fact, if you try to fit it into one of the two categories, you'll probably have a hard time. Thinking of it as an absolute problem with set guides to follow isn't going to help you since you might overlook some cases where those guides simply fall through. You cannot treat every project you take-on as brand new and never before done, you'll spend more time either trying to figure out what structure you're going to create or keep on refactoring your already "never before done" setup.

<Seperator />

## A hybrid-like approach
Well, then how about a hybrid approach? Let's use a predetermined guideline and build from there on forth. It could work, but how many exceptions are introduced? The more anomalies you have, the more memorising you have to do. By having a set structure, you learn it and no matter the scale of your project, you'll always know where to find and put something. Having exceptions mean you have to alter the structure and remember it throughout your journey.

What about the other way around? Let's start composing guidelines to create a composition partially unique to the project. To be honest, I like this idea, but where do you find the micro pieces and how do you know if it's a good fit for your project? At this point, it's not unlikely that overanalysing the structure might end up causing time to be wasted.

<Seperator />

## The perfect sweet spot
Right in the middle, the perfect balance between the two ends of the spectrum. Sounds nice, doesn't it. Just one thing, we'll probably also find a unicorn on our pursuit for this spot...maybe I'm exaggerating a bit. It might just be me not being able to find it.

<Seperator />

# Overcoming the enigma
Up until this point, it might seem like a never-ending struggle toward finding the proper structure for your projects. And believe me, it is. There is hope, though, it gets easier. With enough experience, you start moving toward that perfect sweet spot, but it takes time and effort.

Think of it like this; when it's your first time starting a project, pick an end on the spectrum. Choose a rigid, predefined structure and build something or just start without planning at all. Slowly move your way toward the centre of the two. Ideally, you'll want to be at that sweet spot. Whether you find it or not, the objective is to just start. From there on out you'll become more comfortable with it.

This will allow you to learn and adapt to your mistakes. Not just that, you'll be able to observe the path of other developers and understand the benefits of their approach compared to yours. The adjustments needed to create a near-perfect structure will decrease, and your ability to iterate will increase.

**Just start creating and don't overthink it.**
